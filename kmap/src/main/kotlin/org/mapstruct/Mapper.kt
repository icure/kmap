package org.mapstruct

import org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION
import org.mapstruct.control.MappingControl
import kotlin.reflect.KClass

/**
 * Marks an interface or abstract class as a mapper and activates the generation of a implementation of that type via
 * MapStruct.
 *
 *
 *
 * **Example 1:** Creating mapper
 *
 * <pre>`
 * &#64;Mapper
 * public interface CarMapper {
 * CarDto toCarDto(Car source);
 * }
`</pre> *
 *
 *
 * **Example 2:** Use additional mappers with parameters [.uses], [.componentModel]
 * and [.injectionStrategy]
 *
 * <pre>`
 * // we have MarkMapper (map field "mark" to field "name" to upper case)
 * &#64;Mapper(componentModel = "spring")
 * public class MarkMapper {
 * public String mapMark(String mark) {
 * return mark.toUpperCase();
 * }
 * }
 * // we have CarMapper
 * &#64;Mapper(
 * componentModel = "spring",
 * uses = MarkMapper.class,
 * injectionStrategy = InjectionStrategy.CONSTRUCTOR)
 * public interface CarMapper {
 * &#64;Mapping(source = "mark", target = "name")
 * CarDto convertMap(CarEntity carEntity);
 * }
`</pre> *
 * <pre>`
 * // generates
 * &#64;Component
 * public class CarMapperImpl implements CarMapper {
 * private final MarkMapper markMapper;
 * &#64;Autowired
 * public CarMapperImpl(MarkMapper markMapper) {
 * this.markMapper = markMapper;
 * }
 * &#64;Override
 * public CarDto convertMap(CarEntity carEntity) {
 * if ( carEntity == null ) {
 * return null;
 * }
 * CarDto carDto = new CarDto();
 * carDto.setName( markMapper.mapMark( carEntity.getMark() ) );
 * return carDto;
 * }
 * }
`</pre> *
 *
 * @author Gunnar Morling
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.BINARY)
annotation class Mapper(
    /**
     * Other mapper types used by this mapper. May be hand-written classes or other mappers generated by MapStruct. No
     * cycle between generated mapper classes must be created.
     *
     * @return The mapper types used by this mapper.
     */
    val uses: Array<KClass<*>> = [],
    /**
     * Additional types for which an import statement is to be added to the generated mapper implementation class.
     * This allows to refer to those types from within mapping expressions given via [Mapping.expression],
     * [Mapping.defaultExpression] or using
     * their simple name rather than their fully-qualified name.
     *
     * @return classes to add in the imports of the generated implementation.
     */
    val imports: Array<KClass<*>> = [],
    /**
     * How unmapped properties of the source type of a mapping should be
     * reported. The method overrides an unmappedSourcePolicy set in a central
     * configuration set by [.config]
     *
     * @return The reporting policy for unmapped source properties.
     *
     * @since 1.3
     */
    val unmappedSourcePolicy: ReportingPolicy = ReportingPolicy.IGNORE,
    /**
     * How unmapped properties of the target type of a mapping should be
     * reported. The method overrides an unmappedTargetPolicy set in a central
     * configuration set by [.config]
     *
     * @return The reporting policy for unmapped target properties.
     */
    val unmappedTargetPolicy: ReportingPolicy = ReportingPolicy.WARN,
    /**
     * How lossy (narrowing) conversion, for instance long to integer should be
     * reported. The method overrides an typeConversionPolicy set in a central
     * configuration set by [.config]
     *
     * @since 1.3
     *
     * @return The reporting policy for unmapped target properties.
     */
    val typeConversionPolicy: ReportingPolicy = ReportingPolicy.IGNORE,
    /**
     * Specifies the component model to which the generated mapper should
     * adhere. Supported values are
     *
     *  *  `default`: the mapper uses no component model, instances are
     * typically retrieved via [Mappers.getMapper]
     *  *
     * `cdi`: the generated mapper is an application-scoped CDI bean and
     * can be retrieved via `@Inject`
     *  *
     * `spring`: the generated mapper is a Spring bean and
     * can be retrieved via `@Autowired`
     *  *
     * `jsr330`: the generated mapper is annotated with `@javax.inject.Named` and
     * `@Singleton`, and can be retrieved via `@Inject`
     *
     * The method overrides an unmappedTargetPolicy set in a central configuration set
     * by [.config]
     *
     * @return The component model for the generated mapper.
     */
    val componentModel: String = "default",
    /**
     * Specifies the name of the implementation class. The `<CLASS_NAME>` will be replaced by the
     * interface/abstract class name.
     *
     *
     * Defaults to postfixing the name with `Impl`: `<CLASS_NAME>Impl`
     *
     * @return The implementation name.
     * @see .implementationPackage
     */
    val implementationName: String = "<CLASS_NAME>Impl",
    /**
     * Specifies the target package for the generated implementation. The `<PACKAGE_NAME>` will be replaced by the
     * interface's or abstract class' package.
     *
     *
     * Defaults to using the same package as the mapper interface/abstract class
     *
     * @return the implementation package.
     * @see .implementationName
     */
    val implementationPackage: String = "<PACKAGE_NAME>",
    /**
     * A class annotated with [MapperConfig] which should be used as configuration template. Any settings given
     * via [Mapper] will take precedence over the settings from the referenced configuration source. The list of
     * referenced mappers will contain all mappers given via [Mapper.uses] and [MapperConfig.uses].
     *
     * @return A class which should be used as configuration template.
     */
    val config: KClass<*> = Unit::class,
    /**
     * The strategy to be applied when propagating the value of collection-typed properties. By default, only JavaBeans
     * accessor methods (setters or getters) will be used, but it is also possible to invoke a corresponding adder
     * method for each element of the source collection (e.g. `orderDto.addOrderLine()`).
     *
     *
     * Any setting given for this attribute will take precedence over [MapperConfig.collectionMappingStrategy],
     * if present.
     *
     * @return The strategy applied when propagating the value of collection-typed properties.
     */
    val collectionMappingStrategy: CollectionMappingStrategy = CollectionMappingStrategy.ACCESSOR_ONLY,
    /**
     * The strategy to be applied when `null` is passed as source argument value to the methods of this mapper.
     * If no strategy is configured, the strategy given via [MapperConfig.nullValueMappingStrategy] will be
     * applied, using [NullValueMappingStrategy.RETURN_NULL] by default.
     *
     * @return The strategy to be applied when `null` is passed as source value to the methods of this mapper.
     */
    val nullValueMappingStrategy: NullValueMappingStrategy = NullValueMappingStrategy.RETURN_NULL,
    /**
     * The strategy to be applied when a source bean property is `null` or not present. If no strategy is
     * configured, the strategy given via [MapperConfig.nullValuePropertyMappingStrategy] will be applied,
     * [NullValuePropertyMappingStrategy.SET_TO_NULL] will be used by default.
     *
     * @since 1.3
     *
     * @return The strategy to be applied when `null` is passed as source property value or the source property
     * is not present.
     */
    val nullValuePropertyMappingStrategy: NullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_NULL,
    /**
     * The strategy to use for applying method-level configuration annotations of prototype methods in the interface
     * specified with [.config]. Annotations that can be inherited are for example [Mapping],
     * [IterableMapping], [MapMapping], or [BeanMapping].
     *
     *
     * If no strategy is configured, the strategy given via [MapperConfig.mappingInheritanceStrategy] will be
     * applied, using [MappingInheritanceStrategy.EXPLICIT] as default.
     *
     * @return The strategy to use for applying `@Mapping` configurations of prototype methods in the interface
     * specified with [.config].
     */
    val mappingInheritanceStrategy: MappingInheritanceStrategy = MappingInheritanceStrategy.EXPLICIT,
    /**
     * Determines when to include a null check on the source property value of a bean mapping.
     *
     * Can be overridden by the one on [MapperConfig], [BeanMapping]  or [Mapping].
     *
     * @return strategy how to do null checking
     */
    val nullValueCheckStrategy: NullValueCheckStrategy = ON_IMPLICIT_CONVERSION,
    /**
     * Determines whether to use field or constructor injection. This is only used on annotated based component models
     * such as CDI, Spring and JSR 330.
     *
     * If no strategy is configured, [InjectionStrategy.FIELD] will be used as default.
     *
     * @return strategy how to inject
     */
    val injectionStrategy: InjectionStrategy = InjectionStrategy.FIELD,
    /**
     * If MapStruct could not find another mapping method or apply an automatic conversion it will try to generate a
     * sub-mapping method between the two beans. If this property is set to `true` MapStruct will not try to
     * automatically generate sub-mapping methods.
     *
     *
     * Can be configured by the [MapperConfig.disableSubMappingMethodsGeneration] as well.
     *
     *
     * Note: If you need to use `disableSubMappingMethodsGeneration` please contact the MapStruct team at
     * [mapstruct.org](http://mapstruct.org) or
     * [github.com/mapstruct/mapstruct](https://github.com/mapstruct/mapstruct) to share what problem you
     * are facing with the automatic sub-mapping generation.
     *
     * @return whether the automatic generation of sub-mapping methods is disabled
     *
     * @since 1.2
     */
    val disableSubMappingMethodsGeneration: Boolean = false,
    /**
     * The information that should be used for the builder mappings. This can be used to define custom build methods
     * for the builder strategy that one uses.
     *
     * If no builder is defined the builder given via [MapperConfig.builder] will be applied.
     *
     *
     *
     * NOTE: In case no builder is defined here, in [BeanMapping] or [MapperConfig] and there is a single
     * build method, then that method would be used.
     *
     *
     * If the builder is defined and there is a single method that does not match the name of the build method then
     * a compile error will occur
     *
     * @return the builder information
     *
     * @since 1.3
     */
    val builder: Builder = Builder(),
    /**
     * Allows detailed control over the mapping process.
     *
     * @return the mapping control
     *
     * @since 1.4
     *
     * @see org.mapstruct.control.DeepClone
     *
     * @see org.mapstruct.control.NoComplexMapping
     *
     * @see org.mapstruct.control.MappingControl
     */
    val mappingControl: KClass<out Annotation> = MappingControl::class,
    /**
     * Exception that should be thrown by the generated code if no mapping matches for enums.
     * If no exception is configured, the exception given via [MapperConfig.unexpectedValueMappingException]
     * will be used, using [IllegalArgumentException] by default.
     *
     *
     *
     * Note:
     *
     *  *
     * The defined exception should at least have a constructor with a [String] parameter.
     *
     *  *
     * If the defined exception is a checked exception then the enum mapping methods should have that exception
     * in the throws clause.
     *
     *
     *
     * @return the exception that should be used in the generated code
     *
     * @since 1.4
     */
    val unexpectedValueMappingException: KClass<out Exception> = IllegalArgumentException::class
)
